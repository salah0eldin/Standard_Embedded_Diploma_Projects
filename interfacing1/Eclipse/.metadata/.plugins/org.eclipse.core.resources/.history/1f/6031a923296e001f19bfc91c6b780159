/*
 * main.c
 *
 *  Created on: Sep 8, 2024
 *      Author: Salah-Eldin
 */

#include <avr/io.h>
#include <util/delay.h>
#include <avr/interrupt.h>

#define MODE_BUTTON_STATE  (PINB & _BV(7))

#define H_INC_BUTTON_STATE (PINB & _BV(1))
#define H_DEC_BUTTON_STATE (PINB & _BV(0))
#define M_INC_BUTTON_STATE (PINB & _BV(4))
#define M_DEC_BUTTON_STATE (PINB & _BV(3))
#define S_INC_BUTTON_STATE (PINB & _BV(6))
#define S_DEC_BUTTON_STATE (PINB & _BV(5))

#define TRUE  1
#define FALSE 0

#define COUNT_UP_MODE   0
#define COUNT_DOWN_MODE 1

#define S_ONES_ENABLE 5
#define S_TENS_ENABLE 4
#define M_ONES_ENABLE 3
#define M_TENS_ENABLE 2
#define H_ONES_ENABLE 1
#define H_TENS_ENABLE 0

#define ONES_TENS_CONV 10

#define CLEAR_ENABLE_PINS_MASK 0b11000000
#define CLEAR_DECODER_PINS_MASK 0xF0
#define SEGMENT_DISP_DELAY 2

#define ZERO_INIT 0
#define S_M_LIMIT 59
#define H_LIMIT 23
#define TOTAL_S_LIMIT 86399
#define M_TO_S_CONV 60
#define H_TO_S_CONV 3600

static inline void leds_init(void);
static inline void buzzer_init(void);
static inline void seven_segment_pins_init(void);
static inline void adjust_time_buttons_init(void);
static inline void count_mode_button_init(void);
static inline void reset_button_int0_init(void);
static inline void pause_button_int1_init(void);
static inline void resume_button_int2_init(void);
static inline void timer1_init(void);

static inline void display_time(void);
static inline void update_time(void);

static inline void check_update_mode(void);
static inline void handle_hours_change_buttons(void);
static inline void handle_minutes_change_buttons(void);
static inline void handle_seconds_change_buttons(void);

volatile struct time_t {
	uint8_t seconds;
	uint8_t minutes;
	uint8_t hours;
	uint32_t total_Seconds;
} time;

volatile uint8_t timer1_ticks = 0;

volatile uint8_t paused = 0;

uint8_t mode = COUNT_UP_MODE;

uint8_t modeFlag;
uint8_t hoursIncFlag;
uint8_t hoursDecFlag;
uint8_t minutesIncFlag;
uint8_t minutesDecFlag;
uint8_t secondsIncFlag;
uint8_t secondsDecFlag;

int main() {

	// Initialize system components
	leds_init();
	buzzer_init();
	seven_segment_pins_init();
	adjust_time_buttons_init();
	count_mode_button_init();
	reset_button_int0_init();
	pause_button_int1_init();
	resume_button_int2_init();
	timer1_init();

	// Enable interrupts
	sei();

	for (;;) {
		// Display current time to the 6 multiplexed 7-segments
		display_time();

		// Handle the counting from the timer
		if (timer1_ticks) {
			timer1_ticks--;
			update_time();
		}

		// Check and update the count mode if changed
		check_update_mode();

		// Alarm handling if count down reached zero
		if (COUNT_DOWN_MODE == mode && !time.total_Seconds)
			PORTD |= _BV(0);  // Activate alarm
		else
			PORTD &= ~_BV(0); // Deactivate alarm

		// If paused handle changing time buttons
		if (paused) {

			handle_hours_change_buttons();

			handle_minutes_change_buttons();

			handle_seconds_change_buttons();
		}

	}

	return 0;
}

static inline void leds_init(void) {
	DDRD |= _BV(4) | _BV(5);
	PORTD = (PORTD & ~_BV(5)) | _BV(4);
}

static inline void buzzer_init(void) {
	DDRD |= _BV(0);
	PORTD &= ~_BV(0);
}

static inline void seven_segment_pins_init(void) {
	DDRC |= 0x0F;
	PORTC &= 0xF0;

	DDRA |= 0b00111111;
	PORTA &= 0b11000000;
}

static inline void adjust_time_buttons_init(void) {
	DDRB &= 0b10000100;
	PORTB |= 0b01111011;
}

static inline void count_mode_button_init(void) {
	DDRB &= ~_BV(7);
	PORTB |= _BV(7);
}

static inline void reset_button_int0_init(void) {
	DDRD &= ~_BV(2);
	PORTD |= _BV(2);

	GICR |= _BV(INT0);
	MCUCR |= _BV(ISC01);
	GIFR |= _BV(INTF0);
}

static inline void pause_button_int1_init(void) {
	DDRD &= ~_BV(3);

	GICR |= _BV(INT1);
	MCUCR |= _BV(ISC11) | _BV(ISC10);
	GIFR |= _BV(INTF1);
}

static inline void resume_button_int2_init(void) {
	DDRB &= ~_BV(2);
	PORTB |= _BV(2);

	GICR |= _BV(INT2);
	GIFR |= _BV(INTF2);
}

static inline void timer1_init(void) {
	TCCR1B |= _BV(WGM12) | _BV(CS10) | _BV(CS12);
	TCNT1 = 0;
	OCR1A = 15625;

	TIMSK |= _BV(OCIE1A);
	TIFR |= _BV(OCF1A);
}

static inline void display_time(void) {
	// Disable all the segments and enable the ones of the seconds
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(S_ONES_ENABLE);
	// Display ones of the Seconds
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.seconds % ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);

	// Disable all the segments and enable the tens of the seconds
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(S_TENS_ENABLE);
	// Display tens of the Seconds
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.seconds / ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);

	// Disable all the segments and enable the ones of the minutes
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(M_ONES_ENABLE);
	// Display ones of the Minutes
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.minutes % ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);

	// Disable all the segments and enable the tens of the minutes
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(M_TENS_ENABLE);
	// Display tens of the Minutes
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.minutes / ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);

	// Disable all the segments and enable the ones of the hours
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(H_ONES_ENABLE);
	// Display ones of the Hours
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.hours % ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);

	// Disable all the segments and enable the tens of the hours
	PORTA = (PORTA & CLEAR_ENABLE_PINS_MASK) | _BV(H_TENS_ENABLE);
	// Display tens of the Hours
	PORTC = (PORTC & CLEAR_DECODER_PINS_MASK) | (time.hours / ONES_TENS_CONV);
	_delay_ms(SEGMENT_DISP_DELAY);
}

static inline void update_time(void) {
	if (mode == COUNT_UP_MODE) {

		(time.total_Seconds > TOTAL_S_LIMIT) ?
				(time.total_Seconds = ZERO_INIT) : time.total_Seconds++;
	} else {

		(ZERO_INIT == time.total_Seconds) ?
				(time.total_Seconds = ZERO_INIT) : time.total_Seconds--;
	}

	time.seconds = time.total_Seconds % (S_M_LIMIT + 1);
	time.minutes = (time.total_Seconds / M_TO_S_CONV) % (S_M_LIMIT + 1);
	time.hours = time.total_Seconds / H_TO_S_CONV;
}

static inline void check_update_mode(void) {
	if (!MODE_BUTTON_STATE) {
		if (modeFlag) {
			modeFlag = FALSE;
			mode = (mode == COUNT_UP_MODE) ? COUNT_DOWN_MODE : COUNT_UP_MODE;
			(mode == COUNT_UP_MODE) ?
					(PORTD = (PORTD & ~_BV(5)) | _BV(4)) :
					(PORTD = (PORTD & ~_BV(4)) | _BV(5));
		}
	} else {
		modeFlag = TRUE;
	}
}

static inline void handle_hours_change_buttons(void) {
	if (!H_INC_BUTTON_STATE) {
		if (hoursIncFlag) {
			hoursIncFlag = FALSE;
			if (time.hours < H_LIMIT) {
				time.hours++;
				time.total_Seconds += H_TO_S_CONV;
			}
		}
	} else {
		hoursIncFlag = TRUE;
	}

	if (!H_DEC_BUTTON_STATE) {
		if (hoursDecFlag) {
			hoursDecFlag = FALSE;
			if (time.hours > ZERO_INIT) {
				time.hours--;
				time.total_Seconds -= H_TO_S_CONV;
			}
		}
	} else {
		hoursDecFlag = TRUE;
	}
}

static inline void handle_minutes_change_buttons(void) {
	if (!M_INC_BUTTON_STATE) {
		if (minutesIncFlag) {
			minutesIncFlag = FALSE;
			if (time.minutes < S_M_LIMIT) {
				time.minutes++;
				time.total_Seconds += M_TO_S_CONV;
			}
		}
	} else {
		minutesIncFlag = TRUE;
	}

	if (!M_DEC_BUTTON_STATE) {
		if (minutesDecFlag) {
			minutesDecFlag = FALSE;
			if (time.minutes > ZERO_INIT) {
				time.minutes--;
				time.total_Seconds -= M_TO_S_CONV;
			}
		}
	} else {
		minutesDecFlag = TRUE;
	}
}

static inline void handle_seconds_change_buttons(void) {
	if (!S_INC_BUTTON_STATE) {
		if (secondsIncFlag) {
			secondsIncFlag = FALSE;
			if (time.seconds < S_M_LIMIT) {
				time.seconds++;
				time.total_Seconds++;
			}
		}
	} else {
		secondsIncFlag = TRUE;
	}

	if (!S_DEC_BUTTON_STATE) {
		if (secondsDecFlag) {
			secondsDecFlag = FALSE;
			if (time.seconds > ZERO_INIT) {
				time.seconds--;
				time.total_Seconds--;
			}
		}
	} else {
		secondsDecFlag = TRUE;
	}
}

ISR(TIMER1_COMPA_vect) {
	timer1_ticks++;
}

ISR(INT0_vect) {
	time.total_Seconds = ZERO_INIT;
	time.hours = ZERO_INIT;
	time.minutes = ZERO_INIT;
	time.seconds = ZERO_INIT;
}

ISR(INT1_vect) {
	paused = TRUE;
	TCCR1B &= ~_BV(CS10) & ~_BV(CS12);
}

ISR(INT2_vect) {
	paused = FALSE;
	TCCR1B |= _BV(CS10) | _BV(CS12);
}
